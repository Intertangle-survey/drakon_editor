// Autogenerated with DRAKON Editor 1.33
using System;
using System.Collections.Generic;
using System.Text;

namespace AutomatonTest {

// Look: these constants are used in the BabyFrog state machine
public class Frog {
	public const int Food = 20;
	public const int Sleep = 10;
}

public interface IMachine
{
	object OnMessage(int messageType, char c);
	void Shutdown();
}	

public enum TokenType
{
	None,
	Identifier,
	Number,
	Operator
}

public class Token
{
	public readonly String Text;
	public readonly TokenType Type;
	public Token(string text, TokenType type)
	{
		Text = text;
		Type = type;
	}
	public override string ToString()
	{
		return String.Format("{0} {1}", Text, Type);
	}
}

public class Lexer {

	private static readonly List<string> LongOperators = new List<string>
		{ "==", "<=", ">=", "!=", "&&", "||" };
	private static readonly bool[] OperatorChars = new bool[255];
	
	


    public partial class LexerMachine
        : IMachine
    {
        // Currently built token
        internal readonly StringBuilder Buffer = new StringBuilder();
        // Current list of tokens.
        internal readonly List<Token> Tokens = new List<Token>();

        public enum StateNames {
            Destroyed,
            Idle,
            Identifier,
            Number,
            Operator
        }

        private StateNames _state = StateNames.Idle;

        public StateNames State {
            get { return _state; }
            internal set { _state = value; }
        }

        public const int DigitMessage = 1;
        public const int LetterMessage = 2;
        public const int OperatorMessage = 3;
        public const int WhitespaceMessage = 4;
        public const int dummyMessage = 5;

        public object OnMessage(int messageType, char c) {
            switch (messageType) {
                case DigitMessage:
                    return Digit(c);
                case LetterMessage:
                    return Letter(c);
                case OperatorMessage:
                    return Operator(c);
                case WhitespaceMessage:
                    return Whitespace(c);
                case dummyMessage:
                    return dummy(c);
                default:
                    return null;
            }
        }

        public object Digit(char c) {
            switch (State) {
                case StateNames.Idle:
                    return Idle_Digit(c);
                case StateNames.Identifier:
                    return Identifier_Digit(c);
                case StateNames.Number:
                    return Number_Digit(c);
                case StateNames.Operator:
                    return Operator_Digit(c);
                default:
                    return null;
            }
        }

        public object Letter(char c) {
            switch (State) {
                case StateNames.Idle:
                    return Idle_Letter(c);
                case StateNames.Identifier:
                    return Identifier_Letter(c);
                case StateNames.Number:
                    return Number_Letter(c);
                case StateNames.Operator:
                    return Operator_Letter(c);
                default:
                    return null;
            }
        }

        public object Operator(char c) {
            switch (State) {
                case StateNames.Idle:
                    return Idle_Operator(c);
                case StateNames.Identifier:
                    return Identifier_Operator(c);
                case StateNames.Number:
                    return Number_Operator(c);
                case StateNames.Operator:
                    return Operator_Operator(c);
                default:
                    return null;
            }
        }

        public object Whitespace(char c) {
            switch (State) {
                case StateNames.Idle:
                    return Idle_Whitespace(c);
                case StateNames.Identifier:
                    return Identifier_Whitespace(c);
                case StateNames.Number:
                    return Number_Whitespace(c);
                case StateNames.Operator:
                    return Operator_Whitespace(c);
                default:
                    return null;
            }
        }

        public object dummy(char c) {
            switch (State) {
                case StateNames.Idle:
                    return null;
                case StateNames.Identifier:
                    return null;
                case StateNames.Number:
                    return Number_dummy(c);
                case StateNames.Operator:
                    return null;
                default:
                    return null;
            }
        }

        private object Idle_Whitespace(char c) {
            State = StateNames.Idle;
            return null;
        }

        private object Idle_Letter(char c) {
            AddChar(this, c);
            State = StateNames.Identifier;
            return null;
        }

        private object Idle_Digit(char c) {
            AddChar(this, c);
            State = StateNames.Number;
            return null;
        }

        private object Idle_Operator(char c) {
            AddChar(this, c);
            State = StateNames.Operator;
            return null;
        }

        private object Identifier_Whitespace(char c) {
            CreateIdentifier(this);
            State = StateNames.Idle;
            return null;
        }

        private object Identifier_Letter(char c) {
            AddChar(this, c);
            State = StateNames.Identifier;
            return null;
        }

        private object Identifier_Digit(char c) {
            AddChar(this, c);
            State = StateNames.Identifier;
            return null;
        }

        private object Identifier_Operator(char c) {
            CreateIdentifier(this);
            AddChar(this, c);
            State = StateNames.Operator;
            return null;
        }

        private object Number_Whitespace(char c) {
            CreateNumber(this);
            State = StateNames.Idle;
            return null;
        }

        private object Number_Letter(char c) {
            AddChar(this, c);
            State = StateNames.Number;
            return null;
        }

        private object Number_Digit(char c) {
            AddChar(this, c);
            State = StateNames.Number;
            return null;
        }

        private object Number_Operator(char c) {
            CreateNumber(this);
            AddChar(this, c);
            State = StateNames.Operator;
            return null;
        }

        private object Number_dummy(char c) {
            State = StateNames.Operator;
            return null;
        }

        private object Operator_Whitespace(char c) {
            CreateOperator(this);
            State = StateNames.Idle;
            return null;
        }

        private object Operator_Letter(char c) {
            CreateOperator(this);
            AddChar(this, c);
            State = StateNames.Identifier;
            return null;
        }

        private object Operator_Digit(char c) {
            CreateOperator(this);
            AddChar(this, c);
            State = StateNames.Number;
            return null;
        }

        private object Operator_Operator(char c) {
            if (TryMakeLongOperator(this, c)) {
                State = StateNames.Idle;
                return null;
            } else {
                CreateOperator(this);
                AddChar(this, c);
                State = StateNames.Operator;
                return null;
            }
        }

        public void Shutdown() {
            if (State == StateNames.Destroyed) {
                return;
            }
            State = StateNames.Destroyed;
            
        }
    }

    public partial class Fragile
    {
        

        public enum StateNames {
            Destroyed,
            Working
        }

        private StateNames _state = StateNames.Working;

        public StateNames State {
            get { return _state; }
            internal set { _state = value; }
        }

        public const int helloMessage = 1;

        public object OnMessage(int messageType, int msg) {
            switch (messageType) {
                case helloMessage:
                    return hello(msg);
                default:
                    return null;
            }
        }

        public object hello(int msg) {
            switch (State) {
                case StateNames.Working:
                    return Working_hello(msg);
                default:
                    return null;
            }
        }

        private object Working_hello(int msg) {
            Console.WriteLine("oh dear...");
            Shutdown();
            return null;
        }

        private object Working_default(int msg) {
            State = StateNames.Working;
            return null;
        }

        public void Shutdown() {
            if (State == StateNames.Destroyed) {
                return;
            }
            State = StateNames.Destroyed;
            Console.WriteLine("Fragile: Cleaning up");
        }
    }

    public static List<Token> Lex(string text) {
        Init();
        var lexer = new LexerMachine();
        foreach (char c in text) {
            if ((c == '_') || (Char.IsLetter(c))) {
                lexer.Letter(c);
            } else {
                if (Char.IsDigit(c)) {
                    lexer.Digit(c);
                } else {
                    if (IsOperator(c)) {
                        lexer.Operator(c);
                    } else {
                        lexer.Whitespace(' ');
                    }
                }
            }
        }
        lexer.Whitespace(' ');
        return lexer.Tokens;
    }

    public static List<Token> LexWeak(string text) {
        Init();
        var lexer = new LexerMachine();
        foreach (char c in text) {
            if ((c == '_') || (Char.IsLetter(c))) {
                lexer.OnMessage(
                	LexerMachine.LetterMessage,
                	c
                );
            } else {
                if (Char.IsDigit(c)) {
                    lexer.OnMessage(
                    	LexerMachine.DigitMessage,
                    	c
                    );
                } else {
                    if (IsOperator(c)) {
                        lexer.OnMessage(
                        	LexerMachine.OperatorMessage,
                        	c
                        );
                    } else {
                        lexer.OnMessage(
                        	LexerMachine.WhitespaceMessage,
                        	' '
                        );
                    }
                }
            }
        }
        lexer.OnMessage(
        	LexerMachine.WhitespaceMessage,
        	' '
        );
        return lexer.Tokens;
    }

    public static void Main() {
        string text = "foo.Bar(34 / 4-(18+m * 3));";
        Console.WriteLine("Text:\n{0}", text);
        Console.WriteLine();
        Console.WriteLine("Strongly-typed state machine test");
        Console.WriteLine("Tokens:");
        List<Token> tokens = Lex(text);
        foreach (Token token in tokens) {
            Console.WriteLine(token);
        }
        Console.WriteLine();
        Console.WriteLine("Weakly-typed state machine test");
        Console.WriteLine("Tokens:");
        List<Token> tokens2 = LexWeak(text);
        foreach (Token token2 in tokens2) {
            Console.WriteLine(token2);
        }
        var frog = new BabyFrog();
        Console.WriteLine("The baby frog says:");
        Console.Write(frog.State.ToString() + "/Sleep: ");
        Console.WriteLine(frog.Sleep(0));
        Console.Write(frog.State.ToString() + "/Food: ");
        Console.WriteLine(frog.Food(0));
        Console.Write(frog.State.ToString() + "/Food: ");
        Console.WriteLine(frog.Food(0));
        Console.Write(frog.State.ToString() + "/Sleep: ");
        Console.WriteLine(frog.Sleep(0));
        var frag = new Fragile();
        frag.hello(0);
        Console.WriteLine("No shutdown below");
        frag.Shutdown();
    }

    private static void AddChar(LexerMachine lexer, char c) {
        lexer.Buffer.Append(c);
    }

    private static void CreateIdentifier(LexerMachine lexer) {
        CreateToken(lexer, TokenType.Identifier);
    }

    private static void CreateNumber(LexerMachine lexer) {
        CreateToken(lexer, TokenType.Number);
    }

    private static void CreateOperator(LexerMachine lexer) {
        CreateToken(lexer, TokenType.Operator);
    }

    private static void CreateToken(LexerMachine lexer, TokenType type) {
        if (lexer.Buffer.Length == 0) {
            
        } else {
            string text = lexer.Buffer.ToString();
            lexer.Buffer.Length = 0;
            Token token = new Token(text, type);
            lexer.Tokens.Add(token);
        }
    }

    private static void Init() {
        OperatorChars['!'] = true;
        OperatorChars['='] = true;
        OperatorChars['<'] = true;
        OperatorChars['>'] = true;
        OperatorChars['-'] = true;
        OperatorChars['+'] = true;
        OperatorChars['/'] = true;
        OperatorChars['\\'] = true;
        OperatorChars['*'] = true;
        OperatorChars['%'] = true;
        OperatorChars['('] = true;
        OperatorChars[')'] = true;
        OperatorChars['['] = true;
        OperatorChars[']'] = true;
        OperatorChars['{'] = true;
        OperatorChars['}'] = true;
        OperatorChars[':'] = true;
        OperatorChars['.'] = true;
        OperatorChars[';'] = true;
        OperatorChars[','] = true;
        OperatorChars['^'] = true;
        OperatorChars['|'] = true;
        OperatorChars['&'] = true;
        OperatorChars['"'] = true;
        OperatorChars['\''] = true;
    }

    private static bool IsOperator(char c) {
        if (c >= OperatorChars.Length) {
            return false;
        } else {
            return OperatorChars[c];
        }
    }

    private static bool TryMakeLongOperator(LexerMachine lexer, char c) {
        char previous = lexer.Buffer[0];
        char[] chars = { previous, c };
        string text = new String(chars);
        if (LongOperators.Contains(text)) {
            lexer.Buffer.Length = 0;
            Token token = new Token(text, TokenType.Operator);
            lexer.Tokens.Add(token);
            return true;
        } else {
            return false;
        }
    }
}
}
