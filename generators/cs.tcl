gen::add_generator "C#" gen_cs::generate

namespace eval gen_cs {


variable invoke_cleanup ""
variable link_to_final_found 0


variable cs_keywords {
abstract
as
base
bool
break
byte
case
catch
char
checked
class
const
continue
decimal
default
delegate
do
double
else
enum
event
explicit
extern
false
finally
fixed
float
for
foreach
goto
if
implicit
in
int
interface
internal
is
lock
long
namespace
new
null
object
operator
out
override
params
private
protected
public
readonly
ref
return
sbyte
sealed
short
sizeof
stackalloc
static
string
struct
switch
this
throw
true
try
typeof
uint
ulong
unchecked
unsafe
ushort
using
virtual
void
volatile
while

add
alias
ascending
async
await
descending
dynamic
from
get
global
group
into
join
let
orderby
partial
remove
select
set
value
var
where
yield

}

# Autogenerated with DRAKON Editor 1.33

proc bad_case { switch_var select_icon_number } {
    if {[ string compare -nocase $switch_var "select" ] == 0} {
        return "throw new InvalidOperationException\(\"Condition was not detected.\");"
    } else {
        return "throw new InvalidOperationException\(\"Not expected:  \" + ${switch_var}.ToString()\);"
    }
}

proc change_state { next_state machine_name returns } {
    variable invoke_cleanup
    variable link_to_final_found
    if {$next_state == ""} {
        set link_to_final_found 1
        set change $invoke_cleanup
    } else {
        set change "State = StateNames.${next_state};"
    }
    if {$returns == ""} {
        return "$change\nreturn null;"
    } else {
        set output [ lindex $returns 1 ]
        return "$change\n$output"
    }
}

proc classify_keywords { keywords name } {
    set errors {}
    set access [ gen_cpp::find_keywords $keywords { private public protected internal } ]
    set _sw7500000_ [ llength $access ]
    if {($_sw7500000_ == 0) || ($_sw7500000_ == 1)} {
        
    } else {
        lappend errors "$name: inconsistent access: $access"
    }
    set dispatch [ gen_cpp::find_keywords $keywords { override abstract static virtual } ]
    set _sw7620000_ [ llength $dispatch ]
    if {$_sw7620000_ == 0} {
        set dispatch "normal"
    } else {
        if {$_sw7620000_ == 1} {
            
        } else {
            lappend errors "$name: inconsistent dispatch: $dispatch"
        }
    }
    set subtype [ gen_cpp::find_keywords $keywords { method ctr } ]
    set _sw7730000_ [ llength $subtype ]
    if {$_sw7730000_ == 0} {
        set subtype "method"
    } else {
        if {$_sw7730000_ == 1} {
            
        } else {
            lappend errors "$name: inconsistent method type: $subtype"
        }
    }
    if {(($subtype == "method") || (!($subtype == "ctr"))) || ($dispatch == "normal")} {
        
    } else {
        lappend errors \
        "$name: constructor cannot be $dispatch"
    }
    if {$access == ""} {
        set access "none"
    }
    array set props {}
    set props(access) $access
    set props(dispatch) $dispatch
    set props(type) $subtype
    set proplist [ array get props ]
    set error_message [ join $errors "\n" ]
    return [ list $error_message $proplist ]
}

proc extract_body { comments } {
    set body {}
    set inherits ""
    foreach comment $comments {
        set state "idle"
        set trimmed [ string trim $comment ]
        set lines [ split $trimmed "\n" ]
        foreach line $lines {
            set line [ string trim $line ]
            set section [ string map {" " {}} $line ]
            if {$line == ""} {
                
            } else {
                if {$state == "idle"} {
                    if {($section == "===fields===") || ($section == "===body===")} {
                        set state "fields"
                    } else {
                        if {$section == "===inherits==="} {
                            set state "inherits"
                        }
                    }
                } else {
                    if {$state == "fields"} {
                        if {$section == "===inherits==="} {
                            set state "inherits"
                        } else {
                            lappend body $line
                        }
                    } else {
                        if {$state == "inherits"} {
                            
                        } else {
                            error "Unexpected switch value: $state"
                        }
                        set inherits $line
                        set state "idle"
                    }
                }
            }
        }
    }
    set body_txt [ join $body "\n        " ]
    return [ list $body_txt $inherits ]
}

proc extract_class_name { section } {
    set section [ string map { "\{" " " } $section ]
    set section [ split $section " \t\n" ]
    set count [ llength $section ]
    if {$count < 2} {
        return ""
    } else {
        set found [ lsearch $section "class" ]
        if {$found == -1} {
            set found [ lsearch $section "struct" ]
            if {$found == -1} {
                return ""
            } else {
                set name_pos [ expr { $found + 1 } ]
                if {$name_pos < $count} {
                    return [ lindex $section $name_pos ]
                } else {
                    return ""
                }
            }
        } else {
            set name_pos [ expr { $found + 1 } ]
            if {$name_pos < $count} {
                return [ lindex $section $name_pos ]
            } else {
                return ""
            }
        }
    }
}

proc extract_many_cs_machines { gdb callbacks } {
    variable invoke_cleanup
    variable link_to_final_found
    set result {}
    set diagrams [ $gdb eval {
    	select diagram_id from diagrams } ]
    foreach diagram_id $diagrams {
        if {[graph::is_machine $diagram_id]} {
            set link_to_final_found 0
            set invoke_cleanup "Shutdown\(\);"
            set info [ sma::build_machine $gdb $diagram_id $callbacks ]
            sma::delete_diagram $gdb $diagram_id
            lappend info "has_final" $link_to_final_found
            lappend result $info
        }
    }
    return $result
}

proc extract_signature { text name } {
    array set props { 
    	access none 
    	dispatch normal
    	type method
    }
    set error_message ""
    set parameters {}
    set returns ""
    set type "method"
    set lines [ gen::separate_from_comments $text ]
    if {[ llength $lines ] == 0} {
        
    } else {
        set first_line [ lindex $lines 0 ]
        set first [ lindex $first_line 0 ]
        if {$first == "#comment"} {
            set type "comment"
        } else {
            set keywords { 
            	public private protected internal
            	override abstract static virtual
            	method ctr
            }
            set found_keywords [ gen_cpp::find_keywords $first $keywords ]
            if {[ llength $found_keywords ] == 0} {
                set start_index 0
                set count [ llength $lines ]
                set i $start_index
                while { 1 } {
                    if {$i < $count} {
                        
                    } else {
                        break
                    }
                    set current [ lindex $lines $i ]
                    set stripped [ lindex $current 0 ]
                    if {[ string match "returns *" $stripped ]} {
                        set returns [ gen_cpp::extract_return_type $stripped ]
                    } else {
                        lappend parameters $current
                    }
                    incr i
                }
            } else {
                set start_index 1
                set alien_keywords [ gen_cpp::find_not_belonging $first $keywords ]
                if {[ llength $alien_keywords ] == 0} {
                    lassign [ classify_keywords $found_keywords $name ] \
                    	error_message prop_list
                    if {$error_message == ""} {
                        array unset props
                        array set props $prop_list
                        set type $props(type)
                        set count [ llength $lines ]
                        set i $start_index
                        while { 1 } {
                            if {$i < $count} {
                                
                            } else {
                                break
                            }
                            set current [ lindex $lines $i ]
                            set stripped [ lindex $current 0 ]
                            if {[ string match "returns *" $stripped ]} {
                                set returns [ gen_cpp::extract_return_type $stripped ]
                            } else {
                                lappend parameters $current
                            }
                            incr i
                        }
                    }
                } else {
                    set error_message \
                        "$name: Unexpected keywords: $alien_keywords"
                }
            }
        }
    }
    if {$type == "ctr"} {
        if {$returns == ""} {
            
        } else {
            set error_message \
            "$name: constructors must not have return type"
        }
    } else {
        if {$returns == ""} {
            set returns "void"
        }
    }
    set prop_list [ array get props ]
    set signature [ gen::create_signature $type $prop_list $parameters $returns ]
    set result [ list $error_message $signature ]
    return $result
}

proc find_function_by_name { functions name } {
    foreach function $functions {
        lassign $function diagram_id fname
        if {$fname == $name} {
            return $function
        }
    }
    return {}
}

proc foreach_check { item_id first second } {
    set iter_var "_it$item_id"
    return "$iter_var.MoveNext()"
}

proc foreach_current { item_id first second } {
    lassign [ parse_foreach $item_id $first ] type var
    set iter_var "_it$item_id"
    
    return "$var = $iter_var.Current;"
}

proc foreach_declare { item_id first second } {
    lassign [ parse_foreach $item_id $first ] type var
    set iter_var "_it$item_id"
    set iter_type "IEnumerator<$type>"
    
    
    return "$iter_type $iter_var = null;\n$type $var = default\($type\);"
}

proc foreach_incr { item_id first second } {
    return ""
}

proc foreach_init { item_id first second } {
    lassign [ parse_foreach $item_id $first ] type var
    set iter_var "_it$item_id"
    set col_type "IEnumerable<$type>"
    
    
    return "$iter_var = \(\($col_type\)$second\).GetEnumerator();"
}

proc generate { db gdb filename } {
    set callbacks [ make_callbacks ]
    lassign [ gen::scan_file_description $db \
     { header class footer } ] \
     header class footer
    set raw_machines [ extract_many_cs_machines \
     $gdb $callbacks ]
    set diagrams [ $gdb eval {
    	select diagram_id from diagrams } ]
    foreach diagram_id $diagrams {
        if {[mwc::is_drakon $diagram_id]} {
            gen::fix_graph_for_diagram $gdb $callbacks 1 $diagram_id
        }
    }
    tab::generate_tables $gdb $callbacks 0
    if {[graph::errors_occured]} {
        
    } else {
        set nogoto 1
        set all_functions [ gen::generate_functions \
         $db $gdb $callbacks $nogoto ]
        if {[ graph::errors_occured ]} {
            
        } else {
            if {$class == ""} {
                set class_name ""
                separate_methods $gdb $all_functions functions methods
                set machines [ sma::add_handlers $gdb $raw_machines \
                 $all_functions ]
                set hfile [ replace_extension $filename "cs" ]
                set fhandle [ open_output_file $hfile ]
                catch {
                	p.print_to_file $fhandle $functions \
                		$methods \
                		$header $class $class_name $footer \
                		$machines
                } error_message
                set details $::errorInfo
                catch { close $fhandle }
                if {$error_message == ""} {
                    
                } else {
                    puts $details
                    error $error_message
                }
            } else {
                set class_name [ extract_class_name $class ]
                if {$class_name == ""} {
                    error \
                    "Class or struct is missing in the ===class=== section."
                } else {
                    separate_methods $gdb $all_functions functions methods
                    set machines [ sma::add_handlers $gdb $raw_machines \
                     $all_functions ]
                    set hfile [ replace_extension $filename "cs" ]
                    set fhandle [ open_output_file $hfile ]
                    catch {
                    	p.print_to_file $fhandle $functions \
                    		$methods \
                    		$header $class $class_name $footer \
                    		$machines
                    } error_message
                    set details $::errorInfo
                    catch { close $fhandle }
                    if {$error_message == ""} {
                        
                    } else {
                        puts $details
                        error $error_message
                    }
                }
            }
        }
    }
}

proc generate_body { gdb diagram_id start_item node_list items incoming } {
    set callbacks [ make_callbacks ]
    return [ cbody::generate_body $gdb $diagram_id $start_item $node_list \
    $items $incoming $callbacks ]
}

proc get_message_constants { name messages } {
    set state "none"
    set constants {}
    set names {}
    set i 1
    foreach message $messages {
        set parts [ split $message "." ]
        set last [ lindex $parts end ]
        set count [ llength $parts ]
        lappend names $last
        if {$state == "none"} {
            if {$count == 1} {
                lappend constants \
                 [ list $message $i ]
                set state "internal"
            } else {
                lappend constants \
                 [ list $last $message ]
                set state "external"
            }
        } else {
            if {$state == "internal"} {
                if {$count == 1} {
                    lappend constants \
                     [ list $message $i ]
                } else {
                    error "Cannot combine external and internal message codes: $name"
                }
            } else {
                if {$state == "external"} {
                    
                } else {
                    error "Unexpected switch value: $state"
                }
                if {$count == 1} {
                    error "Cannot combine external and internal message codes: $name"
                } else {
                    lappend constants \
                     [ list $last $message ]
                }
            }
        }
        incr i
    }
    return [list $names $constants]
}

proc handle_message { fhandle ind states message names handlers } {
    puts $fhandle "$ind            switch \(State\) \{"
    foreach state $states {
        set message2 [ string map { - _ . _ } $message ]
        set method "${state}_${message2}"
        puts $fhandle "$ind                case StateNames.$state:"
        if {[ find_function_by_name $handlers $method ] == {}} {
            puts $fhandle "$ind                    return null;"
        } else {
            puts $fhandle "$ind                    return $method\($names\);"
        }
    }
    puts $fhandle "$ind                default:"
    puts $fhandle "$ind                    return null;"
    puts $fhandle "$ind            \}"
}

proc highlight { tokens } {
    variable cs_keywords
    return [ highlight_generic $cs_keywords $tokens ]
}

proc highlight_generic { keywords tokens } {
    set result {}
    set state "idle"
    foreach token $tokens {
        lassign $token type text
        if {$state == "idle"} {
            set state [ idle_default $keywords result $type $text ]
        } else {
            if {$state == "string"} {
                lappend result $colors::syntax_string
                if {$text == "\""} {
                    set state "idle"
                } else {
                    if {$text == "\\"} {
                        set state "escaping"
                    } else {
                        if {$text == "\n"} {
                            set state "idle"
                        }
                    }
                }
            } else {
                if {$state == "escaping"} {
                    lappend result $colors::syntax_string
                    if {$text == "\n"} {
                        set state "idle"
                    } else {
                        set state "string"
                    }
                } else {
                    if {$state == "comment start"} {
                        if {$text == "*"} {
                            set state "comment"
                            lappend result $colors::syntax_comment \
                            	$colors::syntax_comment
                        } else {
                            if {$text == "/"} {
                                set state "comment line"
                                lappend result $colors::syntax_comment \
                                	$colors::syntax_comment
                            } else {
                                lappend result $colors::syntax_operator
                                set state [ idle_default $keywords result $type $text ]
                            }
                        }
                    } else {
                        if {$state == "comment"} {
                            lappend result $colors::syntax_comment
                            if {$text == "*"} {
                                set state "comment end"
                            }
                        } else {
                            if {$state == "comment end"} {
                                lappend result $colors::syntax_comment
                                if {$text == "/"} {
                                    set state "idle"
                                }
                            } else {
                                if {$state == "comment line"} {
                                    lappend result $colors::syntax_comment
                                    if {$text == "\n"} {
                                        set state "idle"
                                    }
                                } else {
                                    if {$state == "char"} {
                                        lappend result $colors::syntax_string
                                        if {$text == "'"} {
                                            set state "idle"
                                        } else {
                                            if {$text == "\\"} {
                                                set state "char escaping"
                                            } else {
                                                if {$text == "\n"} {
                                                    set state "idle"
                                                }
                                            }
                                        }
                                    } else {
                                        if {$state == "char escaping"} {
                                            lappend result \
                                              $colors::syntax_string
                                            if {$text == "\n"} {
                                                set state "idle"
                                            } else {
                                                set state "char"
                                            }
                                        } else {
                                            if {$state == "verbatim start"} {
                                                if {$text == "\""} {
                                                    lappend result $colors::syntax_string \
                                                    	$colors::syntax_string
                                                    set state "verbatim"
                                                } else {
                                                    lappend result $colors::syntax_operator
                                                    set state [ idle_default $keywords result $type $text ]
                                                }
                                            } else {
                                                if {$state == "verbatim"} {
                                                    lappend result $colors::syntax_string
                                                    if {$text == "\""} {
                                                        set state "verbatim end"
                                                    }
                                                } else {
                                                    if {$state == "verbatim end"} {
                                                        
                                                    } else {
                                                        error "Unexpected switch value: $state"
                                                    }
                                                    if {$text == "\""} {
                                                        lappend result $colors::syntax_string
                                                        set state "verbatim"
                                                    } else {
                                                        set state [ idle_default $keywords result $type $text ]
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if {($state == "comment start") || ($state == "verbatim start")} {
        lappend result $colors::syntax_operator
    }
    return $result
}

proc idle_default { keywords result_name type text } {
    upvar 1 $result_name result
    if {$text == "\""} {
        lappend result $colors::syntax_string
        set state "string"
    } else {
        if {$text == "'"} {
            lappend result $colors::syntax_string
            set state "char"
        } else {
            if {$text == "/"} {
                set state "comment start"
            } else {
                if {$text == "@"} {
                    set state "verbatim start"
                } else {
                    lappend result [standard_color $keywords $type $text]
                    set state "idle"
                }
            }
        }
    }
    return $state
}

proc is_ctr { method } {
    set signature [ lindex $method 2 ]
    set type [ lindex $signature 0 ]
    return [ expr { $type == "ctr" } ]
}

proc is_weak { machine } {
    set params [ dict get $machine "parameters" ]
    if {[ llength $params ] == 1} {
        set first [ lindex $params 0 ]
        if {$first == "state machine"} {
            return 1
        } else {
            return 0
        }
    } else {
        return 0
    }
}

proc make_callbacks { } {
    set callbacks {}
    
    gen::put_callback callbacks assign			gen_java::assign
    gen::put_callback callbacks compare			gen_java::compare
    gen::put_callback callbacks compare2		gen_java::compare
    gen::put_callback callbacks while_start 	gen_java::while_start
    gen::put_callback callbacks if_start		gen_java::if_start
    gen::put_callback callbacks elseif_start	gen_java::elseif_start
    gen::put_callback callbacks if_end			gen_java::if_end
    gen::put_callback callbacks else_start		gen_java::else_start
    gen::put_callback callbacks pass			gen_java::pass
    gen::put_callback callbacks continue		gen_java::p.continue
    gen::put_callback callbacks return_none		gen_java::return_none
    gen::put_callback callbacks block_close		gen_java::block_close
    gen::put_callback callbacks comment			gen_java::commentator
    
    gen::put_callback callbacks break			"break;"
    gen::put_callback callbacks and				gen_java::p.and
    gen::put_callback callbacks or				gen_java::p.or
    gen::put_callback callbacks not				gen_java::p.not
    gen::put_callback callbacks declare		gen_java::p.declare
    
    
    gen::put_callback callbacks bad_case		gen_cs::bad_case
    
    gen::put_callback callbacks body			gen_cs::generate_body
    gen::put_callback callbacks signature		gen_cs::extract_signature
    	
    gen::put_callback callbacks for_check		gen_cs::foreach_check
    gen::put_callback callbacks for_current		gen_cs::foreach_current
    gen::put_callback callbacks for_init		gen_cs::foreach_init
    gen::put_callback callbacks for_incr		gen_cs::foreach_incr
    gen::put_callback callbacks for_declare		gen_cs::foreach_declare
    gen::put_callback callbacks shelf gen_cs::shelf
    gen::put_callback callbacks change_state gen_cs::change_state
    gen::put_callback callbacks shutdown "Shutdown"
    gen::put_callback callbacks fsm_merge   0
    gen::put_callback callbacks native_foreach gen_cs::native_foreach
    return $callbacks
}

proc method_of_access { procedure access } {
    set signature [ lindex $procedure 2 ]
    set type [ lindex $signature 0 ]
    if {$type == "method"} {
        set props_list [ lindex $signature 1 ]
        array set props $props_list
        if {$props(access) == $access} {
            return 1
        } else {
            return 0
        }
    } else {
        return 0
    }
}

proc native_foreach { for_it for_var } {
    return "foreach ($for_it in $for_var) \{"
}

proc p.print_proc { weak_signature fhandle procedure class_name depth } {
    lassign $procedure diagram_id name signature body
    if {$class_name == ""} {
        
    } else {
        set name $class_name
    }
    lassign $signature type prop_list parameters returns
    array set props $prop_list
    set indent [ gen::make_indent $depth ]
    set body_depth [ expr { $depth + 1 } ]
    set lines [ gen::indent $body $body_depth ]
    if {$name == "Shutdown"} {
        set props(access) "public"
        set returns "void"
    }
    set header ""
    if {$props(access) == "none"} {
        
    } else {
        append header "$props(access) "
    }
    if {$props(dispatch) == "normal"} {
        
    } else {
        append header "$props(dispatch) "
    }
    if {$type == "ctr"} {
        
    } else {
        append header "$returns "
    }
    append header "$name\("
    if {$name == "Shutdown"} {
        set params {}
    } else {
        set params [ map2 $parameters gen_cs::take_first ]
        if {[lindex $params 0 ] == "state machine"} {
            set params [ lrange $params 1 end ]
        }
    }
    append header [ join $params ", " ]
    append header "\)"
    puts $fhandle ""
    if {$props(dispatch) == "abstract"} {
        puts $fhandle "$indent$header;"
    } else {
        puts $fhandle "$indent$header \{"
        if {$name == "Shutdown"} {
            puts $fhandle "$indent    if \(State == StateNames.Destroyed\) \{"
            puts $fhandle "$indent        return;"
            puts $fhandle "$indent    \}"
            puts $fhandle "$indent    State = StateNames.Destroyed;"
        }
        puts $fhandle $lines
        puts $fhandle "$indent\}"
    }
}

proc p.print_to_file { fhandle functions methods header class class_name footer machines } {
    set version [ version_string ]
    puts $fhandle \
        "// Autogenerated with DRAKON Editor $version"
    puts $fhandle $header
    puts $fhandle $class
    print_machines $fhandle $machines
    init_current_file $fhandle
    generate_data_struct $class_name $methods
    set ctrs      [ lfilter $functions gen_java::is_ctr ]
    set public    [ lfilter_user $functions gen_java::method_of_access "public"    ]
    set none      [ lfilter_user $functions gen_java::method_of_access "none"      ]
    set protected [ lfilter_user $functions gen_java::method_of_access "protected" ]
    set private   [ lfilter_user $functions gen_java::method_of_access "private"   ]
    set internal  [ lfilter_user $functions gen_java::method_of_access "internal"  ]
    print_procs 0 $fhandle $ctrs $class_name 1
    print_procs 0 $fhandle $public "" 1
    print_procs 0 $fhandle $internal "" 1
    print_procs 0 $fhandle $protected "" 1
    print_procs 0 $fhandle $private "" 1
    print_procs 0 $fhandle $none "" 1
    if {$class_name == ""} {
        
    } else {
        puts $fhandle "\}"
    }
    puts $fhandle $footer
}

proc parse_foreach { item_id init } {
    set length [ llength $init ]
    if {$length == 2} {
        
    } else {
        set message "item id: $item_id, wrong syntax in foreach. Should be: Type variable; collection"
    }
    return $init
}

proc print_bad { fhandle state method class_name } {
    set message "\"$class_name: Method '$method' is not expected in state '$state'.\""
    puts $fhandle "        throw new System.InvalidOperationException\($message\);"
    puts $fhandle "    \}"
}

proc print_good { fhandle state param_names } {
    set arg_list [ join $param_names ", " ]
    set method "${state}_default"
    puts $fhandle "        $method\($arg_list\);"
    puts $fhandle "    \}"
}

proc print_handler { fhandle states message params names handlers } {
    puts $fhandle ""
    puts $fhandle "        public object $message\($params\) \{"
    handle_message $fhandle "" $states $message $names $handlers
    puts $fhandle "        \}"
}

proc print_header { fhandle state message parameters } {
    set arg_list [ join $parameters ", " ]
    puts $fhandle "    private object ${state}_${message}\($arg_list\)"
    puts $fhandle "    \{"
}

proc print_machine { fhandle machine } {
    if {$machine == {}} {
        
    } else {
        set parameters [ dict get $machine "parameters" ]
        set param_names [ dict get $machine "param_names" ]
        set last [ dict get $machine "last" ]
        set boiler [ dict get $machine "boiler" ]
        set messages [ dict get $machine "messages" ]
        set states [ dict get $machine "states" ]
        set name [ dict get $machine "name" ]
        set handlers [ dict get $machine "handlers" ]
        set comments [ dict get $machine "comments" ]
        set has_final [ dict get $machine "has_final" ]
        set weak [ is_weak $machine ]
        lassign \
        [extract_body $comments] \
        body inherits
        puts $fhandle ""
        puts $fhandle "    public partial class $name"
        set real_params [ lrange $parameters 1 end ]
        set params [ join $real_params ", " ]
        set pnames [ lrange $param_names 1 end ]
        set pnames_str [ join $pnames ", " ]
        set arg_name_list [ join $pnames ", " ]
        if {$inherits == ""} {
            
        } else {
            puts $fhandle "        : $inherits"
        }
        puts $fhandle "    \{"
        puts $fhandle "        $body"
        puts $fhandle ""
        puts $fhandle "        public enum StateNames \{"
        puts $fhandle "            Destroyed,"
        set enum [ join $states ",\n            " ]
        puts $fhandle "            $enum"
        puts $fhandle "        \}"
        set first [ lindex $states 0 ]
        puts $fhandle ""
        puts $fhandle "        private StateNames _state = StateNames.$first;"
        puts $fhandle ""
        puts $fhandle "        public StateNames State \{"
        puts $fhandle "            get \{ return _state; \}"
        puts $fhandle "            internal set \{ _state = value; \}"
        puts $fhandle "        \}"
        puts $fhandle ""
        lassign \
        [get_message_constants $name $messages] \
        messages mconstants
        set i 1
        foreach message $mconstants {
            lassign $message name value
            puts $fhandle \
              "        public const int ${name}Message = $value;"
            incr i
        }
        puts $fhandle ""
        puts $fhandle "        public object OnMessage(int messageType, $params\) \{"
        puts $fhandle "            switch \(messageType\) \{"
        foreach message $messages {
            puts $fhandle "                case ${message}Message:"
            puts $fhandle "                    return ${message}\($pnames_str\);"
        }
        puts $fhandle "                default:"
        puts $fhandle "                    return null;"
        puts $fhandle "            \}"
        puts $fhandle "        \}"
        foreach message $messages {
            print_handler $fhandle \
              $states $message $params $arg_name_list \
              $handlers
        }
    }
    foreach procedure $handlers {
        lassign $procedure _ proc_name
        set proc2 [ set_void_return $procedure ]
        p.print_proc $weak $fhandle $proc2 "" 2
    }
    puts $fhandle "    \}"
}

proc print_machines { fhandle machines } {
    foreach machine $machines {
        print_machine $fhandle $machine
    }
}

proc print_procs { weak_signature fhandle procedures class_name depth } {
    foreach procedure $procedures {
        p.print_proc $weak_signature $fhandle $procedure $class_name $depth
    }
}

proc print_special_state_class { fhandle messages iface name parameters line } {
    set lines {}
    set count [ llength $messages ]
    set i 0
    while { 1 } {
        if {$i < $count} {
            
        } else {
            break
        }
        lappend lines $line
        incr i
    }
    print_state_class $fhandle $messages $iface $name $parameters $lines
}

proc print_state_class { fhandle messages iface name parameters lines } {
    set sname "${name}_State_Definition"
    puts $fhandle "    private class $sname : $iface \{"
    puts $fhandle "        public string Name \{ get \{ return \"$name\"; \} \}"
    set i 0
    foreach message $messages {
        puts $fhandle "        public void $message\($parameters\) \{"
        set line [ lindex $lines $i ]
        puts $fhandle "            $line"
        puts $fhandle "        \}"
        incr i
    }
    puts $fhandle "    \}"
    puts $fhandle "    public static readonly $iface ${name}_State = new $sname\(\);"
}

proc print_state_method { fhandle message parameters param_names iface } {
    set all_arg_names [ linsert $param_names 0 "this" ]
    set arg_list [ join $all_arg_names ", " ]
    puts $fhandle "    public void ${message}\($parameters\) \{"
    puts $fhandle "        $iface current = _state;"
    puts $fhandle "        _state = Intermediate_State;"
    puts $fhandle "        current.${message}\($arg_list\);"
    puts $fhandle "    \}"
}

proc separate_methods { gdb all_functions functions_name methods_name } {
    upvar $functions_name functions
    upvar $methods_name methods
    array set methods_by_class {}
    set functions {}
    foreach function $all_functions {
        lassign $function diagram_id name signature body
        if {[sma::is_from_machine $gdb $diagram_id]} {
            
        } else {
            lassign \
            [try_parse_method_name $diagram_id $name] \
            class_name method_name is_method
            if {$is_method} {
                set class [ tab::find_class $class_name ]
                if {$class == ""} {
                    gen::report_error $diagram_id {} \
                    "Unknown class: '$class_name'"
                } else {
                    if {[info exists methods_by_class($class)]} {
                        set class_methods $methods_by_class($class)
                    } else {
                        set class_methods {}
                    }
                    set function2 [ list \
                     $diagram_id $method_name $signature $body ]
                    lappend class_methods $function2
                    set methods_by_class($class) $class_methods
                }
            } else {
                lappend functions $function
            }
        }
    }
    set methods [ array get methods_by_class ]
}

proc set_void_return { procedure } {
    lassign $procedure diagram_id name signature body
    lassign $signature type prop_list parameters returns
    set returns2 "object"
    set signature2 [ list $type $prop_list $parameters $returns2 ]
    return [ list $diagram_id $name $signature2 $body ]
}

proc shelf { primary secondary } {
    return "$secondary = $primary;"
}

proc standard_color { keywords type text } {
    if {$type == "op"} {
        return $colors::syntax_operator
    } else {
        if {$type == "number"} {
            return $colors::syntax_number
        } else {
            if {($type == "token") && ([contains $keywords $text])} {
                return $colors::syntax_keyword
            } else {
                return $colors::syntax_identifier
            }
        }
    }
}

proc take_first { item } {
    return [ lindex $item 0 ]
}

proc try_parse_method_name { diagram_id name } {
    set parts [ split $name "." ]
    if {[ llength $parts ] == 2} {
        lassign $parts first second
        if {($first == "") || ($second == "")} {
            return [ list "" "" 0 ]
        } else {
            return [ list $first $second 1 ]
        }
    } else {
        return [ list "" "" 0 ]
    }
}

}
